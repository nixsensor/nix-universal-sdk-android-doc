<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>Nix Universal SDK</title>
    <link href="images/logo-icon.svg" rel="icon" type="image/svg">
    <script>var pathToRoot = "";</script>
    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="scripts/sourceset_dependencies.js" async="async"></script>
<link href="styles/style.css" rel="Stylesheet">
<link href="styles/jetbrains-mono.css" rel="Stylesheet">
<link href="styles/main.css" rel="Stylesheet">
<link href="styles/prism.css" rel="Stylesheet">
<link href="styles/logo-styles.css" rel="Stylesheet">
<script type="text/javascript" src="scripts/clipboard.js" async="async"></script>
<script type="text/javascript" src="scripts/navigation-loader.js" async="async"></script>
<script type="text/javascript" src="scripts/platform-content-handler.js" async="async"></script>
<script type="text/javascript" src="scripts/main.js" defer="defer"></script>
<script type="text/javascript" src="scripts/prism.js" async="async"></script>
<script type="text/javascript" src="scripts/symbol-parameters-wrapper_deferred.js" defer="defer"></script>
</head>
<body>
<div class="navigation-wrapper" id="navigation-wrapper">
    <div id="leftToggler"><span class="icon-toggler"></span></div>
    <div class="library-name">
            <a href="index.html">
                    <span>Nix Universal SDK</span>
            </a>
    </div>
    <div>
    </div>
    <div class="pull-right d-flex">
        <button id="theme-toggle-button"><span id="theme-toggle"></span></button>
        <div id="searchBar"></div>
    </div>
</div>
<div id="container">
    <div id="leftColumn">
        <div id="sideMenu"></div>
    </div>
    <div id="main">
<div class="main-content" id="content" pageIds="Nix Universal SDK::////PointingToDeclaration//-343231423">
  <div class="breadcrumbs"></div>
  <div class="cover ">
    <h1 class="cover"><span><span>Nix</span></span> <span><span>Universal</span></span> <span><span>SDK</span></span></h1>
    <div class="platform-hinted UnderCoverText" data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":universalsdk:dokkaHtml/release"><p class="paragraph">A library to allow integration of Nix devices into third party Android applications.</p><p class="paragraph">The latest version of this documentation is available <a href="https://www.nixsensor.com/sdk-doc-android">online</a>.</p><h2 class=""> Overview</h2><p class="paragraph">This library was written to allow integration of Nix devices into third party Android applications. It provides tools to discover nearby Nix devices, open a connection, perform measurements, and obtain data. Tools are also provided for basic colour conversions and colour difference calculations.</p><p class="paragraph">The <code class="lang-kotlin">universalsdk</code> library replaces the previous <code class="lang-kotlin">nixlibrary</code> library. These two libraries should not be used together; remove <code class="lang-kotlin">nixlibrary</code> from your project before adding <code class="lang-kotlin">universalsdk</code>.</p><h3 class=""> Minimum Requirements</h3><ul><li><p class="paragraph">Android Studio (tested with 2021.3.1 Patch 1)</p></li><li><p class="paragraph">Android Studio project with <code class="lang-kotlin">minSdkVersion</code> 21 or higher</p></li><li><p class="paragraph">Android device with BLE hardware connectivity</p></li><li><p class="paragraph">Supported Nix devices:</p></li><ul><li><p class="paragraph">Nix Mini</p></li><li><p class="paragraph">Nix Mini 2</p></li><li><p class="paragraph">Nix Mini 3</p></li><li><p class="paragraph">Nix Pro</p></li><li><p class="paragraph">Nix Pro 2</p></li><li><p class="paragraph">Nix QC</p></li><li><p class="paragraph">Nix Spectro 2</p></li></ul></ul><h2 class=""> Usage</h2><h3 class=""> Adding support for Nix devices to your Android Studio project</h3><p class="paragraph">The Nix <code class="lang-kotlin">universalsdk</code> library is provided as a zipped Maven repository. This can be used as a local, folder-based repository, or integrated into a private repository management system. This example outlines its usage as a local, folder-based repository.</p><ul><li><p class="paragraph">Unzip the provided <code class="lang-kotlin">nixrepo.zip</code> file to the root directory of your Android Studio project. The resulting folder structure should similar to:</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">PROJECT_ROOT<br>├── app<br>│   ├── src<br>│   │   ├── ...<br>│   ├── build.gradle<br>│   ├── ...<br>├── build.gradle<br>├── nixrepo<br>│   ├── com<br>│   │   ├── nixsensor<br>│   │   │   ├── universalsdk<br>│   │   │   │   ├── ...<br>├── settings.gradle<br>├── ...</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><ul><li><p class="paragraph">Add the <code class="lang-kotlin">nixrepo</code> and <code class="lang-kotlin">jitpack.io</code> repositories to your project, typically in the <code class="lang-kotlin">dependencyResolutionManagement</code> section of your project's <code class="lang-kotlin">settings.gradle</code> file</p></li></ul><div class="sample-container"><pre><code class="block lang-gradle" theme="idea">dependencyResolutionManagement {<br>    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br>    repositories {<br>        google()<br>        mavenCentral()<br>        <br>        // Jitpack repo needed for Nix Universal SDK cross-dependencies<br>        maven { url 'https://jitpack.io' }<br>        <br>        // Point to folder-based `nixrepo` repository. If you have stored <br>        // `nixrepo` in a repository management system, point the url to that<br>        // location instead<br>        maven { url &quot;file://$rootDir/nixrepo&quot; }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><ul><li><p class="paragraph">Add the <code class="lang-kotlin">com.nixsensor:universalsdk</code> dependency to your app level <code class="lang-kotlin">build.gradle</code> file</p></li></ul><div class="sample-container"><pre><code class="block lang-gradle" theme="idea">dependencies {<br>    // Your existing dependencies here<br>    // ...<br><br>    // Nix Universal SDK<br>    implementation 'com.nixsensor:universalsdk:4.0.2'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><ul><li><p class="paragraph">As of Android SDK version 23 (Marshmallow), certain permissions must be requested from the user at run-time, including those necessary for discovering nearby Bluetooth devices.</p></li><ul><li><p class="paragraph">These permissions must be requested at runtime prior to using the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a> class</p></li><li><p class="paragraph">The specific permissions to request depend on the Android version, and are provided by <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-companion/required-bluetooth-permissions.html">requiredBluetoothPermissions</a></p></li><li><p class="paragraph">A helper function <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-companion/request-bluetooth-permissions.html">requestBluetoothPermissions</a> is provided to request the appropriate permissions depending on the currently running Android version</p></li><li><p class="paragraph">The helper function <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-companion/is-bluetooth-permission-granted.html">isBluetoothPermissionGranted</a> is provided to check if these permissions have already been granted by the user</p></li><li><p class="paragraph">The following example code requests these permissions at the creation of an <code class="lang-kotlin">Activity</code>. Note that requesting this permission does not need to occur immediately at the beginning of your <code class="lang-kotlin">Activity</code>, but simply needs to be performed prior to using the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a> class.</p></li></ul></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">companion object {<br>  // Define a constant value of your choice here<br>  const val PERMISSION_REQUEST_BLUETOOTH = 1000    <br>}<br><br>override fun onCreate(savedInstanceState: Bundle?) {<br>  super.onCreate(savedInstanceState)<br>  // ...<br>  <br>  // Request Bluetooth permissions if necessary<br>  if (!IDeviceScanner.isBluetoothPermissionGranted(this)) {<br>    IDeviceScanner.requestBluetoothPermissions(<br>      activity = this, <br>      requestCode = PERMISSION_REQUEST_BLUETOOTH<br>    )<br>  }<br>}<br><br>override fun onRequestPermissionsResult(<br>  requestCode: Int,<br>  permissions: Array&lt;out String&gt;,<br>  grantResults: IntArray<br>) {<br>  super.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>  <br>  // Check if all requested permissions have been granted<br>  var allGranted = true<br>  for (result in grantResults) allGranted =<br>    allGranted and (result == PackageManager.PERMISSION_GRANTED)<br>  <br>  when (requestCode) {<br>    PERMISSION_REQUEST_BLUETOOTH -&gt; {<br>      if (allGranted) {<br>        // All permissions granted, OK to use `DeviceScanner`<br>        // ...          <br>      } else {<br>        // Handle permission denial<br>        // ...<br>      }        <br>    }      <br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Discovering Nix devices</h3><p class="paragraph">Regardless of device type, each unique Nix device can be represented by an object that conforms to the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/index.html">IDeviceCompat</a> interface. To obtain instances of the device object, they need to first be discovered using the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a>. They can also be recalled at a later time directly using their <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/id.html">id</a> property (for Bluetooth connected devices only).</p><p class="paragraph">The <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a> implements the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/index.html">IDeviceScanner</a> interface and searches for nearby Nix devices using Bluetooth. The <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a> will also report devices connected via USB. Scanner events are reported via:</p><ul><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-on-scanner-state-change-listener/index.html">OnScannerStateChangeListener</a>:</p></li><ul><li><p class="paragraph">Optional callback interface which reports when the scanner starts and stops searching for devices.</p></li><li><p class="paragraph">This is set using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/set-on-scanner-state-change-listener.html">setOnScannerStateChangeListener</a></p></li></ul><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-on-device-found-listener/index.html">OnDeviceFoundListener</a>:</p></li><ul><li><p class="paragraph">Callback interface which is called by the scanner each time that an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/index.html">IDeviceCompat</a> instance has been found</p></li><li><p class="paragraph">Note that this will be called both when a new device is found and when the RSSI/signal strength of a previously discovered device has changed. It is possible to use the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/id.html">id</a> parameter as a means to uniquely identify discovered devices.</p></li></ul></ul><p class="paragraph">To use the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a>:</p><ul><li><p class="paragraph">Initialize a scanner instance</p></li><li><p class="paragraph">Optionally set a <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-on-scanner-state-change-listener/index.html">OnScannerStateChangeListener</a>, if it is desired to track when the scanner starts and stops a device search</p></li><li><p class="paragraph">The scanner can be started using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/start.html">start</a></p></li><ul><li><p class="paragraph">By default, the scanner will search for a period <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-companion/-d-e-f-a-u-l-t_-g-e-n-e-r-a-l_-s-c-a-n_-p-e-r-i-o-d_-m-s.html">DEFAULT_GENERAL_SCAN_PERIOD_MS</a>, but this interval can be overridden by providing an argument for <code class="lang-kotlin">scanPeriodMs</code>.</p></li></ul><li><p class="paragraph">Discovered devices will be reported via a <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-on-device-found-listener/index.html">OnDeviceFoundListener</a> interface. At this stage, it is valid to check a limited number of parameters on the device object:</p></li><ul><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/id.html">id</a>: Device identifier string</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/rssi.html">rssi</a>: Device signal strength (-127 to 0). Will be 0 for USB connected devices</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/interface-type.html">interfaceType</a>: Indicates whether the device was found via Bluetooth or USB connection</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/type.html">type</a>: Indicates the specific device type</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/name.html">name</a>: Full name of the device (e.g. 'Nix Spectro 2')</p></li></ul></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val scannerStateListener = object : OnScannerStateChangeListener {<br>  override fun onScannerStarted(sender: IDeviceScanner) {<br>    // Scanner has started ...<br>  }<br><br>  override fun onScannerStopped(sender: IDeviceScanner) {<br>    // Scanner has stopped ...<br>  }<br>}<br><br>val deviceFoundListener = object : OnDeviceFoundListener {<br>  override fun onScanResult(sender: IDeviceScanner, device: IDeviceCompat) {<br>    // Nearby device found<br>    // Handle discovery here ...<br><br>    // Valid to query some parameters now:<br>    Log.d(TAG, String.format(<br>      &quot;Found %s (%s) at RSSI %d&quot;, <br>      device.id, <br>      device.name, <br>      device.rssi)<br>    )<br>  }<br>}<br><br>// Application context, in a Fragment use getContext()<br>val context: Context<br><br>// Initialize the scanner<br>val scanner = DeviceScanner(context)<br>scanner.setOnScannerStateChangeListener(scannerStateListener)<br><br>// Start the scanner<br>scanner.start(listener = deviceFoundListener)</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><ul><li><p class="paragraph">The device search will run for the specified duration, after which <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/-on-scanner-state-change-listener/on-scanner-stopped.html">onScannerStopped</a> is called. The device search can also be manually stopped using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/stop.html">stop</a>.</p></li></ul><h3 class=""> Recalling a known Nix device</h3><p class="paragraph">For Bluetooth connected devices only, it is possible to construct a <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-compat/index.html">DeviceCompat</a> instance directly if the hardware address and device type is known. The constructor takes the hardware address and device names as arguments.</p><ul><li><p class="paragraph">The device address <strong>must</strong> match the original value queried from <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/id.html">id</a>. Note that this corresponds to the hardware address of the advertising Bluetooth device</p></li><li><p class="paragraph">The device name <strong>must</strong> match the original value queried from <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/name.html">name</a>. Note that this corresponds to the device name as advertised on Bluetooth. If the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-type/index.html">DeviceType</a> is known, this also corresponds to <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-type/full-name.html">fullName</a></p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// Application context, in a Fragment use getContext()<br>val context: Context<br><br>// Hardware address of known device<br>val exampleAddress: String = &quot;00:AA:11:BB:22:CC&quot;<br><br>// Name of known device / type (must match advertised name)<br>val exampleName: String = &quot;Nix Spectro 2&quot;<br><br>// Create IDeviceCompat instance<br>val recalledDevice: IDeviceCompat = DeviceCompat(<br>  context = context,<br>  address = exampleAddress,<br>  name = exampleName<br>)</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Connecting to a Nix device</h3><p class="paragraph">Once an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/index.html">IDeviceCompat</a> instance has been obtained, a connection can be opened by calling <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/connect.html">connect</a>. Connection state changes are provided via a <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/index.html">OnDeviceStateChangeListener</a> interface.</p><ul><li><p class="paragraph">Implement the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/index.html">OnDeviceStateChangeListener</a> interface in your class</p></li><li><p class="paragraph">Stop the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-scanner/index.html">DeviceScanner</a> before opening a connection, if still running.</p></li><ul><li><p class="paragraph">It is safe to call <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-scanner/stop.html">stop</a> at any time, even if already stopped</p></li></ul><li><p class="paragraph">Start the connection process using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/connect.html">connect</a></p></li><ul><li><p class="paragraph">The connection process is asynchronous and <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/connect.html">connect</a> will return immediately. If a connection activity indicator is shown, it can be shown immediately before calling this method.</p></li><li><p class="paragraph">A call to <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/connect.html">connect</a> will always result in either the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/on-connected.html">onConnected</a> or <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/on-disconnected.html">onDisconnected</a> event being triggered.</p></li><li><p class="paragraph">Device operations are not possible until the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/on-connected.html">onConnected</a> callback is received (successful connection)</p></li><li><p class="paragraph">If the connection process fails, <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/on-disconnected.html">onDisconnected</a> will be called with an appropriate status code indicating the cause of the error.</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/-on-device-state-change-listener/on-disconnected.html">onDisconnected</a> will also be called later whenever the device is disconnected. This can occur normally (i.e. - if the host device calls <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/disconnect.html">disconnect</a>), or abnormally (i.e. - if the connection is dropped due to an error or low Bluetooth signal strength).</p></li><li><p class="paragraph">The supplied framework binaries are linked to a specific allocation of Nix devices and will not operate with devices from another allocation. At connection time, the SDK will verify an allocation code stored on the Nix device. If this check does not pass, the SDK will contact a Nix authentication server to check if that device serial number is authorized. If the device cannot be authenticated (i.e. – an unknown allocation code was found and an internet connection is unavailable), the device will be disconnected with the status <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-device-status/-e-r-r-o-r_-u-n-a-u-t-h-o-r-i-z-e-d/index.html">ERROR_UNAUTHORIZED</a> . The internet connection is required only once every 30 days – once authorized, this status is saved, and connections can be made offline for this time period.</p></li></ul><li><p class="paragraph">When the user has finished using the device, the connection can be closed using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/disconnect.html">disconnect</a></p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// Define OnDeviceStateChangeListener<br>val deviceStateListener = object : OnDeviceStateChangeListener {<br>  override fun onConnected(<br>    sender: IDeviceCompat<br>  ) {<br>    // Device has connected successfully<br>    // Device properties can now be queried<br>    // Device commands/operations can now run<br>    // ...<br>  }<br><br>  override fun onDisconnected(<br>    sender: IDeviceCompat, <br>    status: DeviceStatus<br>  ) {<br>    // Handle status codes here, if desired in your application<br>    // At minimum, should check for ERROR_UNAUTHORIZED status<br>    when (status) {<br>      // Device not authorized for this SDK build<br>      DeviceStatus.ERROR_UNAUTHORIZED -&gt; {<br>        // ...<br>      }<br><br>      // Normal disconnect, triggered by device.disconnect()<br>      DeviceStatus.SUCCESS -&gt; {<br>        // ...<br>      }<br><br>      // Nix device dropped the connection<br>      DeviceStatus.ERROR_DROPPED_CONNECTION -&gt; {<br>        // ...<br>      }<br><br>      // Connection to Nix device timed out<br>      DeviceStatus.ERROR_TIMEOUT -&gt; { <br>        // ...<br>      }<br><br>      // Other internal errors<br>      DeviceStatus.ERROR_MAX_ATTEMPTS,<br>      DeviceStatus.ERROR_UNSUPPORTED_DEVICE,<br>      DeviceStatus.ERROR_INTERNAL -&gt; { <br>        // ...<br>      }<br>    }<br>  }<br><br>  override fun onBatteryStateChanged(<br>    sender: IDeviceCompat, <br>    newState: Int<br>  ) {<br>    super.onBatteryStateChanged(sender, newState)<br><br>    // Battery level has updated<br>    // ...<br>  }<br><br>  override fun onExtPowerStateChanged(<br>    sender: IDeviceCompat, <br>    newState: Boolean<br>  ) {<br>    super.onExtPowerStateChanged(sender, newState)<br>    // External power has been connected or disconnected<br>    // ...<br>  }    <br>}<br><br>// Device instance found by the DeviceScanner<br>var device: IDeviceCompat<br><br>// Initiate the connection<br>device.connect(deviceStateListener)</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Device operations</h3><h4 class=""> Taking measurements</h4><p class="paragraph">Once the device is connected and in an idle state, it is possible to take measurements using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/measure.html">measure</a>:</p><ul><li><p class="paragraph">The varargs <code class="lang-kotlin">modes</code> argument may be omitted to run measurements in all modes supported by the device. This is the recommended option.</p></li><li><p class="paragraph">If the varargs <code class="lang-kotlin">modes</code> arguments are supplied, measurements will be provided only for the specified scan modes. In most cases, this will not speed up the measurement cycle time, so this is not recommended.</p></li><li><p class="paragraph">The measurement operation is asynchronous and will return immediately. While the measurement is in progress, no other commands can be sent to the Nix device</p></li><li><p class="paragraph">Results of the measurement operation are provided in <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-on-device-result-listener/on-device-result.html">onDeviceResult</a>. This provides two arguments:</p></li><ul><li><p class="paragraph">A <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-command-status/index.html">CommandStatus</a> status code, which will be <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-command-status/-s-u-c-c-e-s-s/index.html">SUCCESS</a> for a successful operation.</p></li><li><p class="paragraph">A map containing the measurement values as <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> objects. The keys of this dictionary correspond to the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/index.html">ScanMode</a> for each measurement value.</p></li><li><p class="paragraph">See <i>Handling measurement data below</i> for notes on interpreting the measurement data.</p></li><li><p class="paragraph">The supported scan modes for a particular device are provided in the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supported-modes.html">supportedModes</a> list, or can be checked by calling <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/is-mode-supported.html">isModeSupported</a>. The expected results by device are shown below:</p></li></ul></ul><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Device Type</td><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/-m0/index.html">M0</a></td><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/-m1/index.html">M1</a></td><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/-m2/index.html">M2</a></td></tr><tr><td>Mini</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>Mini 2</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>Mini 3</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>Pro</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>Pro 2</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>QC</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td>Spectro 2 (F1.0.0)</td><td>☑</td><td>☑</td><td>☐</td></tr><tr><td>Spectro 2 (F2.0.0)</td><td>☑</td><td>☑</td><td>☑</td></tr></tbody></table><h4 class=""> Performing in-field profiling / calibration with reference tile</h4><p class="paragraph">Certain device types support in-field profiling or calibration using a provided reference tile. This process requires first decoding a string from the QR code attached to the reference tile and then directing the user to measure the same tile. Any necessary adjustments/corrections are performed internally by the SDK and/or the Nix device firmware itself.</p><ul><li><p class="paragraph">The in-field calibration procedure may be performed as often or seldom as desired by the user. However, the property <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/field-calibration-due.html">fieldCalibrationDue</a> flag indicates whether or not in-field calibration is recommended for the connected device.</p></li><ul><li><p class="paragraph">This flag is updated after each regular measurement</p></li><li><p class="paragraph">This flag is determined automatically by both elapsed time and ambient temperature change</p></li></ul><li><p class="paragraph">The property <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supports-field-calibration.html">supportsFieldCalibration</a> indicates whether or not a connected device supports this feature. The expected result by device are shown below:</p></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Device Type</td><td>Supported</td></tr><tr><td>Mini</td><td>☐</td></tr><tr><td>Mini 2</td><td>☐</td></tr><tr><td>Mini 3</td><td>☑</td></tr><tr><td>Pro</td><td>☐</td></tr><tr><td>Pro 2</td><td>☐</td></tr><tr><td>QC</td><td>☑</td></tr><tr><td>Spectro 2</td><td>☑</td></tr></tbody></table><ol><li><p class="paragraph">Decode the QR code printed on the device reference tile and interpret as a string. Do not parse this data further.</p></li><li><p class="paragraph">Check if the parsed data is valid using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/is-tile-string-valid.html">isTileStringValid</a>. If valid, continue to the next step.</p></li><li><p class="paragraph">Instruct the user to place the device on the reference tile.</p></li><li><p class="paragraph">Using the decoded tile string, run the in-field calibration routine using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/run-field-calibration.html">runFieldCalibration</a> and wait for callback.</p></li></ol><ul><li><p class="paragraph">This operation is asynchronous and returns immediately. While the operation is in progress, no other commands can be sent to the Nix device (wait for the callback)</p></li><li><p class="paragraph">Every call to <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/run-field-calibration.html">runFieldCalibration</a> will result in a callback with either a success or error code.</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// String decoded from the reference tile<br>val tileString: String<br><br>// Callback for field calibration<br>val listener = object : OnDeviceResultListener {<br>  override fun onDeviceResult(<br>    status: CommandStatus,<br>    measurements: Map&lt;ScanMode, IMeasurementData&gt;?<br>  ) {<br>    when (status) {<br>      CommandStatus.SUCCESS -&gt; {<br>        // Successful operation<br>        // ...        <br>      }<br><br>      CommandStatus.ERROR_SCAN_DELTA -&gt; {<br>        // Operation failed because the measured value of the reference<br>        // tile is too far from the expected value (high delta E)<br>        // ...<br>          <br>      }<br>      CommandStatus.ERROR_NOT_READY -&gt; {<br>        // Scan did not complete because the device was busy<br>        // ...          <br>      }<br><br>      CommandStatus.ERROR_NOT_SUPPORTED -&gt; {<br>        // Scan did not complete because this device does not support<br>        // this command<br>        // ...          <br>      }<br><br>      CommandStatus.ERROR_INVALID_ARGUMENT -&gt; {<br>        // Scan did not complete because the tileString is invalid<br>        // ...          <br>      }<br><br>      CommandStatus.ERROR_LOW_POWER -&gt; {<br>        // Scan did not complete because the battery level is too low<br>        // ...<br>      }<br><br>      CommandStatus.ERROR_TIMEOUT -&gt; {<br>        // Timeout when waiting for result<br>        // ...<br>      }<br><br>      CommandStatus.ERROR_AMBIENT_LIGHT -&gt; {<br>        // Scan did not complete because of ambient light leakage<br>        // ...<br>      }<br>      else -&gt; {<br>        // Scan did not complete because of other internal error<br>        // ...          <br>      }<br>    }<br>  }<br>}<br><br>// Run field calibration scan<br>device.runFieldCalibration(listener, tileString)</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class=""> Other device options</h4><p class="paragraph">Some Nix devices support certain <code class="lang-kotlin">boolean</code> options. These options are set to be enabled by default (if supported) and do not usually need to be changed:</p><ul><li><p class="paragraph">Applying temperature compensation</p></li><ul><li><p class="paragraph">Current state: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/temperature-compensation-enabled.html">temperatureCompensationEnabled</a></p></li><li><p class="paragraph">Is supported?: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supports-temperature-compensation.html">supportsTemperatureCompensation</a></p></li></ul><li><p class="paragraph">Applying in-field calibration</p></li><ul><li><p class="paragraph">Current state: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/field-calibration-enabled.html">fieldCalibrationEnabled</a></p></li><li><p class="paragraph">Is supported?: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supports-field-calibration.html">supportsFieldCalibration</a></p></li></ul><li><p class="paragraph">Using on-device haptic feedback</p></li><ul><li><p class="paragraph">Current state: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/haptic-feedback-enabled.html">hapticFeedbackEnabled</a></p></li><li><p class="paragraph">Is supported?: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supports-haptic-feedback.html">supportsHapticFeedback</a></p></li></ul><li><p class="paragraph">Using on-device RGB feedback</p></li><ul><li><p class="paragraph">Current state: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/rgb-feedback-enabled.html">rgbFeedbackEnabled</a></p></li><li><p class="paragraph">Is supported?: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supports-rgb-feedback.html">supportsRgbFeedback</a></p></li></ul></ul><p class="paragraph">A summary of device support is shown below, but can be checked at runtime (see notes above).</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Device type</td><td>Temp comp.</td><td>Field cal.</td><td>Haptic</td><td>RGB</td></tr><tr><td>Mini</td><td>☐</td><td>☐</td><td>☐</td><td>☐</td></tr><tr><td>Mini 2</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td></tr><tr><td>Mini 3</td><td>☑</td><td>☑</td><td>☐</td><td>☑</td></tr><tr><td>Pro</td><td>☐</td><td>☐</td><td>☐</td><td>☐</td></tr><tr><td>Pro 2</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td></tr><tr><td>QC</td><td>☑</td><td>☑</td><td>☐</td><td>☐</td></tr><tr><td>Spectro 2</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td></tr></tbody></table><p class="paragraph">Changing any of these options may require communication with the device itself and is an asynchronous operation, with the status of the operation provided via an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-on-device-result-listener/index.html">OnDeviceResultListener</a> interface.</p><ul><li><p class="paragraph">To enable or bypass temperature compensation, see <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/set-temperature-compensation-enabled.html">setTemperatureCompensationEnabled</a></p></li><li><p class="paragraph">To enable or bypass applying in-field calibration, see <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/set-field-calibration-enabled.html">setFieldCalibrationEnabled</a></p></li><li><p class="paragraph">To enable or disable haptic feedback, see <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/set-haptic-feedback-enabled.html">setHapticFeedbackEnabled</a></p></li><li><p class="paragraph">To enable or disable RGB feedback, see <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/set-rgb-feedback-enabled.html">setRgbFeedbackEnabled</a></p></li></ul><h4 class=""> Other device properties</h4><p class="paragraph">The <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/index.html">IDeviceCompat</a> interface defines other fixed properties that can be read once the device has connected and reached an idle state. These include, but are not limited to:</p><ul><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/ext-power-state.html">extPowerState</a>: status of external power connection / charging</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/battery-level.html">batteryLevel</a>: current battery level, <code class="lang-kotlin">null</code> otherwise</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/firmware-version.html">firmwareVersion</a>: device firmware revision</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/hardware-version.html">hardwareVersion</a>: device hardware revision</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/software-version.html">softwareVersion</a>: device software revision</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/serial-number.html">serialNumber</a>: device serial number</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/note.html">note</a>: device allocation / production code</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/provides-spectral.html">providesSpectral</a>: indicates whether or not this device provides spectral data</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/provides-density.html">providesDensity</a>: inidcates whether or not this device provides density data</p></li><li><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-device-compat/supported-references.html">supportedReferences</a>: list of supported reference white values provided by the measurement data from this device</p></li></ul><h3 class=""> Handling measurement data</h3><p class="paragraph">Measurements from Nix devices are provided as objects conforming to the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> interface. These contain all data and metadata to completely describe the measurement. Color, spectral, and density data are obtained from the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> object as <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a>, <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html">ISpectralData</a>, and <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/index.html">IDensityData</a> respectively. The differences between these object types are listed below.</p><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a>:</p><ul><li><p class="paragraph">Corresponds to a single measurement in a single <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/index.html">ScanMode</a> from a Nix device</p></li><li><p class="paragraph">Provides color data as <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a></p></li><ul><li><p class="paragraph">To get color data use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/to-color-data.html">toColorData</a></p></li><li><p class="paragraph">All devices provide data for <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d50_2/index.html">D50/2°</a> reference white</p></li><li><p class="paragraph">Some devices provide additional color data for other reference white values</p></li><li><p class="paragraph">To check if available, use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/provides-color.html">providesColor</a></p></li></ul><li><p class="paragraph">May provide spectral data as <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html">ISpectralData</a>, depending on the device type</p></li><ul><li><p class="paragraph">To check if available: check the property <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/provides-spectral.html">providesSpectral</a></p></li><li><p class="paragraph">To get spectral data, use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/spectral-data.html">spectralData</a></p></li></ul><li><p class="paragraph">May provide density data as <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/index.html">IDensityData</a>, depending on the device type</p></li><ul><li><p class="paragraph">To check if available: check the property <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/provides-density.html">providesDensity</a></p></li><li><p class="paragraph">To get density data, use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/to-density-data.html">toDensityData</a></p></li></ul><li><p class="paragraph">The measurement data contains all data and metadata to completely describe the measurement</p></li><ul><li><p class="paragraph">For maximum fidelity and ease of use when saving data, save the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/raw.html">raw</a> string data</p></li><li><p class="paragraph">The raw string value can be used to reconstruct measurement data using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/-companion/from-raw.html">fromRaw</a></p></li></ul></ul><p class="paragraph"><strong>Supported </strong><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html"><strong>IColorData</strong></a><strong> output based on device type</strong></p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Reference</td><td>Mini</td><td>Mini 2</td><td>Mini 3</td><td>Pro</td><td>Pro 2</td><td>QC</td><td>Spectro 2</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-a_2/index.html">A/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-a_10/index.html">A/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-c_2/index.html">C/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-c_10/index.html">C/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d50_2/index.html">D50/2°</a></td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d50_10/index.html">D50/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d55_2/index.html">D55/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d55_10/index.html">D55/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d65_2/index.html">D65/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d65_10/index.html">D65/10°</a></td><td>☐</td><td>☑</td><td>☑</td><td>☐</td><td>☑</td><td>☑</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d75_2/index.html">D75/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d75_10/index.html">D75/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f2_2/index.html">F2/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f2_10/index.html">F2/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f7_2/index.html">F7/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f7_10/index.html">F7/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f11_2/index.html">F11/2°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr><tr><td><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-f11_10/index.html">F11/10°</a></td><td>☐</td><td>☐</td><td>☑</td><td>☐</td><td>☐</td><td>☐</td><td>☑</td></tr></tbody></table><p class="paragraph"><strong>Supported </strong><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html"><strong>ISpectralData</strong></a><strong> and </strong><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/index.html"><strong>IDensityData</strong></a><strong> output based on device type</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Device Type</td><td>Supports spectral output</td><td>Supports density output</td></tr><tr><td>Mini</td><td>☐</td><td>☐</td></tr><tr><td>Mini 2</td><td>☐</td><td>☐</td></tr><tr><td>Mini 3</td><td>☐</td><td>☐</td></tr><tr><td>Pro</td><td>☐</td><td>☐</td></tr><tr><td>Pro 2</td><td>☐</td><td>☐</td></tr><tr><td>QC</td><td>☐</td><td>☐</td></tr><tr><td>Spectro 2</td><td>☑</td><td>☑</td></tr></tbody></table><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a>:</p><ul><li><p class="paragraph">Consists of colorimetry data for a single reference white point (eg - <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/-d50_2/index.html">D50/2°</a>) and single measurement mode</p></li><li><p class="paragraph">Can be obtained directly from an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> object, or an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html">ISpectralData</a> object</p></li><li><p class="paragraph">Full description of a color consisting of:</p></li><ul><li><p class="paragraph">Type / color system: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/type.html">type</a></p></li><ul><li><p class="paragraph">One of <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-type/-c-i-e-x-y-z/index.html">CIEXYZ</a>, <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-type/-c-i-e-l-a-b/index.html">CIELAB</a>, <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-type/-c-i-e-l-c-h/index.html">CIELCH</a>, <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-type/-c-i-e-l-u-v/index.html">CIELUV</a></p></li></ul><li><p class="paragraph">Value: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/value.html">value</a></p></li><ul><li><p class="paragraph">Numeric array (three channels)</p></li><li><p class="paragraph">Format matches the system defined by <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/type.html">type</a></p></li></ul><li><p class="paragraph">Reference white point: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/reference.html">reference</a></p></li><ul><li><p class="paragraph">One of <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-reference-white/index.html">ReferenceWhite</a> enum</p></li></ul><li><p class="paragraph">Scan mode: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/mode.html">mode</a></p></li><ul><li><p class="paragraph">One of <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-scan-mode/index.html">ScanMode</a> enum</p></li></ul></ul><li><p class="paragraph">Regardless of <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/type.html">type</a>, the color is always backed internally by a CIEXYZ value</p></li><li><p class="paragraph">Color can be converted between any of the types specified in the <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-type/index.html">ColorType</a> enum using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/convert-to.html">convertTo</a></p></li><li><p class="paragraph">Delta E to another <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a> can be evaluated using <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/compare-to.html">compareTo</a></p></li><ul><li><p class="paragraph">Both <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a> objects must share the same reference, otherwise the result with be NaN</p></li><li><p class="paragraph">If the color difference type is not specified, the default is <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/-color-difference-type/index.html">CIE2000</a></p></li></ul><li><p class="paragraph">sRGB value can be fetched from <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/rgb-value.html">rgbValue</a></p></li></ul><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html">ISpectralData</a>:</p><ul><li><p class="paragraph">Consists of spectral data for a single measurement mode</p></li><li><p class="paragraph">Obtained from an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> object that supports spectral data</p></li><li><p class="paragraph">Full description of the spectral measurement consisting of:</p></li><ul><li><p class="paragraph">Scan mode: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/mode.html">mode</a></p></li><li><p class="paragraph">Wavelength values: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/lambda.html">lambda</a> (numeric array)</p></li><li><p class="paragraph">Spectral values: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/value.html">value</a> (numeric array)</p></li></ul><li><p class="paragraph">Can be used to obtain density data as an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/index.html">IDensityData</a> object</p></li><ul><li><p class="paragraph">Use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/to-density-data.html">toDensityData</a></p></li></ul><li><p class="paragraph">Can be used to obtain colorimetry data as an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-color-data/index.html">IColorData</a> object for any reference white</p></li><ul><li><p class="paragraph">Use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/to-color-data.html">toColorData</a></p></li></ul><li><p class="paragraph">sRGB value can be fetched for any reference white</p></li><ul><li><p class="paragraph">Use <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/to-rgb-value.html">toRgbValue</a></p></li></ul></ul><p class="paragraph"><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/index.html">IDensityData</a>:</p><ul><li><p class="paragraph">Consists of density data for a single measurement mode and single 'ISO status' / lookup table</p></li><li><p class="paragraph">Obtained from an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-measurement-data/index.html">IMeasurementData</a> object that supports spectral data, or an <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-spectral-data/index.html">ISpectralData</a> object</p></li><li><p class="paragraph">Description of the density values for a specific 'ISO Status' consisting of:</p></li><ul><li><p class="paragraph">Scan mode: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/mode.html">mode</a></p></li><li><p class="paragraph">ISO status: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/status.html">status</a></p></li><li><p class="paragraph">Density values: <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/value.html">value</a></p></li><ul><li><p class="paragraph">Index 0: C</p></li><li><p class="paragraph">Index 1: M</p></li><li><p class="paragraph">Index 2: Y</p></li><li><p class="paragraph">Index 3: K</p></li></ul><li><p class="paragraph">Automatic density index <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-i-density-data/auto-index.html">autoIndex</a></p></li></ul></ul><h3 class=""> Other utilities</h3><p class="paragraph">The <a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/-color-utils/-companion/index.html">ColorUtils</a> class provides many helpful functions for manual colour conversions and delta E calculations.</p><h2 class=""> Additional Support</h2><p class="paragraph">This document is not intended as an exhaustive reference. Please refer to the on-line documentation in the <i>Packages</i> section below for further details on the classes and methods provided by the Nix SDK. An example app is also provided in the SDK archive.</p><p class="paragraph">If you encounter any issues with SDK implementation, please contact us via:</p><ul><li><p class="paragraph">E-mail: <a href="mailto:sdk@nixsensor.com">sdk@nixsensor.com</a></p></li><li><p class="paragraph">Phone (Monday to Friday 9 a.m. to 5 p.m. Eastern Time)</p></li><ul><li><p class="paragraph">Toll Free (North America): 1 (800) 649-1387</p></li><li><p class="paragraph">Main Office: 1 (905) 581-6363</p></li><li><p class="paragraph">San Francisco: 1 (415) 632-3448</p></li></ul></ul><h3 class=""> Privacy Disclaimer</h3><p class="paragraph">Limited anonymous usage data is tracked by the Nix SDK using Google Analytics. No personal user data is collected and no data which uniquely identifies an individual Nix device is collected. Collected data is subject to the Nix Apps privacy policy which is available at <a href="https://www.nixsensor.com/nix-apps-privacy-policy/">https://www.nixsensor.com/nix-apps-privacy-policy/</a>. Events and usage data tracked by the Nix SDK are solely limited to the following information:</p><ul><li><p class="paragraph">Device connection events:</p></li><ul><li><p class="paragraph">Device type (e.g. – Nix Pro, Nix Mini, etc)</p></li><li><p class="paragraph">Device manufacturing batch identifier</p></li><li><p class="paragraph">Nix SDK build identifier</p></li></ul><li><p class="paragraph">Device color scan events:</p></li><ul><li><p class="paragraph">Device type</p></li><li><p class="paragraph">Scanned color data</p></li></ul></ul></div></div>
  </div>
  <h2 class="">Packages</h2>
  <div class="table"><a data-name="-2004121419%2FPackages%2F-343231423" anchor-label="com.nixsensor.universalsdk" id="-2004121419%2FPackages%2F-343231423" data-filterable-set=":universalsdk:dokkaHtml/release"></a>
    <div class="table-row" data-filterable-current=":universalsdk:dokkaHtml/release" data-filterable-set=":universalsdk:dokkaHtml/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-nix -universal -s-d-k/com.nixsensor.universalsdk/index.html">com.nixsensor.universalsdk</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-2004121419%2FPackages%2F-343231423"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right"></div>
        </div>
        <div></div>
      </div>
    </div>
  </div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2023 Copyright</span><span
                class="pull-right"><span>Generated by </span><a
                href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
    </div>
</div>
</body>
</html>
