{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nix Universal SDK","text":"<p>A library to allow integration of Nix devices into third party Android applications.</p> <p>The latest version of this documentation is available online.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library was written to allow integration of Nix devices into third party Android applications. It provides tools to discover nearby Nix devices, open a connection, perform measurements, and obtain data. Tools are also provided for basic colour conversions and colour difference calculations.</p> <p>The <code>universalsdk</code> library replaces the previous <code>nixlibrary</code> library. These two libraries should not be used together; remove <code>nixlibrary</code> from your project before adding <code>universalsdk</code>.</p>"},{"location":"#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Android Studio (tested with 2022.2.1 Patch 2)</li> <li>Android Studio project with <code>minSdkVersion</code> 21 or higher</li> <li>Android device with BLE hardware connectivity</li> <li>Supported Nix devices:<ul> <li>Nix Mini</li> <li>Nix Mini 2</li> <li>Nix Mini 3</li> <li>Nix Pro</li> <li>Nix Pro 2</li> <li>Nix QC</li> <li>Nix Spectro 2</li> <li>Nix Spectro L</li> </ul> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>The <code>universalsdk</code> library is provided as a zipped Maven repository which must be added to your Android Studio project before it can be referenced. See Adding to Your Android Studio Project for instructions.</li> <li>Once added to your Android Studio project, the <code>DeviceScanner</code> can be used to discover nearby and attached devices as <code>IDeviceCompat</code> instances. These objects can be used to open a connection to the the device. See Discovering and Connecting to Nix Devices for more details.</li> <li>Once connected, measurements and other device operations can be performed using the <code>IDeviceCompat</code> instance. Device parameters can also be queried. See Device Operations for more details.</li> <li>Once a measurement has been completed, results are provided as <code>IMeasurementData</code> instances. These objects provide colorimetry data, density, and spectral measurements (if supported by the device). See Handling Measurement Data for more details</li> <li>Several additional utility functions are provided by the <code>ColorUtils</code> class. These include functions for manual colour conversions, delta E calculations, and more. Further details are provided in the API reference (Kotlin and Java)</li> <li>To demonstrate integration of the Nix Universal SDK, an example app is provided with the SDK download.</li> </ol>"},{"location":"#additional-support","title":"Additional Support","text":"<p>This document is not intended as an exhaustive reference. Please refer to the Kotlin and Java API references for further details on the classes and methods provided by the Nix Universal SDK.</p> <p>If you encounter any issues with SDK implementation, please contact us via:</p> <ul> <li>E-mail: sdk@nixsensor.com</li> <li>Phone (Monday to Friday 9 a.m. to 5 p.m. Eastern Time)<ul> <li>Toll Free (North America): 1 (800) 649-1387</li> <li>Main Office: 1 (905) 581-6363</li> <li>San Francisco: 1 (415) 632-3448</li> </ul> </li> </ul>"},{"location":"#privacy-disclaimer","title":"Privacy Disclaimer","text":"<p>Limited anonymous usage data is tracked by the Nix Universal SDK using Google Analytics. No personal user data is collected and no data which uniquely identifies an individual Nix device is collected. Collected data is subject to the Nix Apps privacy policy. Events and usage data tracked by the Nix SDK are solely limited to the following information:</p> <ul> <li>Device connection events:<ul> <li>Device type (e.g. - Nix Pro, Nix Mini, etc)</li> <li>Device manufacturing batch identifier</li> <li>Nix SDK build identifier</li> </ul> </li> <li>Device color scan events:<ul> <li>Device type</li> <li>Scanned color data</li> </ul> </li> </ul>"},{"location":"add-to-as/","title":"Adding to Your Android Studio Project","text":"<p>The <code>universalsdk</code> library is provided as a zipped Maven repository. This can be used as a local, folder-based repository, or integrated into a private repository management system. This example outlines its usage as a local, folder-based repository.</p>"},{"location":"add-to-as/#add-a-local-maven-repository","title":"Add a local Maven repository","text":"<ul> <li>Unzip the provided <code>nixrepo.zip</code> file to the root directory of your Android Studio project. The resulting folder structure should similar to:</li> </ul> <pre><code>PROJECT_ROOT\n\u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 build.gradle\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 build.gradle\n\u251c\u2500\u2500 nixrepo\n\u2502   \u251c\u2500\u2500 com\n\u2502   \u2502   \u251c\u2500\u2500 nixsensor\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 universalsdk\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 settings.gradle\n\u251c\u2500\u2500 ...\n</code></pre> <ul> <li>Add the <code>nixrepo</code> and <code>jitpack.io</code> repositories to your project, typically in the <code>dependencyResolutionManagement</code> section of your project's <code>settings.gradle</code> file</li> </ul> <pre><code>dependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n\n        // Jitpack repo needed for Nix Universal SDK cross-dependencies\n        maven { url 'https://jitpack.io' }\n\n        // Point to folder-based `nixrepo` repository. If you have stored \n        // `nixrepo` in a repository management system, point the url to that\n        // location instead\n        maven { url \"file://$rootDir/nixrepo\" }\n    }\n}\n</code></pre> <ul> <li>Add the <code>com.nixsensor:universalsdk</code> dependency to your app level <code>build.gradle</code> file</li> </ul> <pre><code>dependencies {\n    // Your existing dependencies here\n    // ...\n\n    // Nix Universal SDK\n    implementation 'com.nixsensor:universalsdk:4.1.0'\n}\n</code></pre>"},{"location":"add-to-as/#requesting-required-permissions","title":"Requesting required permissions","text":"<p>As of Android SDK version 23 (Marshmallow), certain permissions must be requested from the user at run-time, including those necessary for discovering nearby Bluetooth devices.</p> <ul> <li>These permissions must be requested at runtime prior to using the <code>DeviceScanner</code> class.</li> <li>The specific permissions to request depend on the Android version. The <code>getRequiredBluetoothPermissions()</code> property getter provides this list of permissions at runtime (see Kotlin or Java APIs).</li> <li>A helper function <code>requestBluetoothPermissions</code> is provided to request the appropriate permissions depending on the currently running Android version (see Kotlin or Java APIs).</li> <li>The helper function <code>isBluetoothPermissionGranted</code> is provided to check if these permissions have already been granted by the user (see Kotlin or Java APIs).</li> </ul> <p>The following example code requests these permissions at the creation of an <code>Activity</code>. Note that requesting this permission does not need to occur immediately at the beginning of your <code>Activity</code>, but simply needs to be performed prior to using the <code>DeviceScanner</code> class.</p> KotlinJava <pre><code>companion object {\n// Define a constant value of your choice here\nconst val PERMISSION_REQUEST_BLUETOOTH = 1000    }\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n// ...\n\n// Request Bluetooth permissions if necessary\nif (!IDeviceScanner.isBluetoothPermissionGranted(this)) {\nIDeviceScanner.requestBluetoothPermissions(\nactivity = this,\nrequestCode = PERMISSION_REQUEST_BLUETOOTH\n)\n}\n}\n\noverride fun onRequestPermissionsResult(\nrequestCode: Int,\npermissions: Array&lt;out String&gt;,\ngrantResults: IntArray\n) {\nsuper.onRequestPermissionsResult(requestCode, permissions, grantResults)\n\n// Check if all requested permissions have been granted\nvar allGranted = true\nfor (result in grantResults) allGranted =\nallGranted and (result == PackageManager.PERMISSION_GRANTED)\n\nwhen (requestCode) {\nPERMISSION_REQUEST_BLUETOOTH -&gt; {\nif (allGranted) {\n// All permissions granted, OK to use `DeviceScanner`\n// ...          \n} else {\n// Handle permission denial\n// ...\n}        }      }\n}\n</code></pre> <pre><code>// Define a constant value of your choice here\nprivate static final int PERMISSION_REQUEST_BLUETOOTH = 1000;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n// ...\n\n// Request Bluetooth permissions if necessary\nif (!IDeviceScanner.Companion.isBluetoothPermissionGranted(this)) {\nIDeviceScanner.Companion.requestBluetoothPermissions(\nthis,\nPERMISSION_REQUEST_BLUETOOTH);\n}\n}\n\n@Override\npublic void onRequestPermissionsResult(\nint requestCode,\n@NonNull String[] permissions,\n@NonNull int[] grantResults\n) {\nsuper.onRequestPermissionsResult(requestCode, permissions, grantResults);\n\n// Check if all requested permissions have been granted\nboolean allGranted = true;\nfor (int result : grantResults) {\nallGranted &amp;= (result == PackageManager.PERMISSION_GRANTED);\n}            switch (requestCode) {\ncase PERMISSION_REQUEST_BLUETOOTH: {\nif (allGranted) {\n// All permissions granted, OK to use `DeviceScanner`\n// ... \n} else {\n// Handle permission denial\n// ...\n}\n}   break;\n}\n}\n</code></pre>"},{"location":"add-to-as/#next-steps","title":"Next steps","text":"<ul> <li>Discovering and Connecting to Nix Devices</li> </ul>"},{"location":"device-operations/","title":"Device Operations","text":""},{"location":"device-operations/#taking-measurements","title":"Taking measurements","text":"<p>Once the device is connected and in an idle state, it is possible to take measurements by calling <code>measure()</code> (see Kotlin or Java APIs). </p> <ul> <li>The varargs <code>modes</code> argument may be omitted to run measurements in all modes supported by the device. This is the recommended option.</li> <li>If the varargs <code>modes</code> arguments are supplied, measurements will be provided only for the specified scan modes. In most cases, this will not speed up the measurement cycle time, so this is not recommended.</li> <li>The measurement operation is asynchronous and will return immediately. While the measurement is in progress, no other commands can be sent to the Nix device.</li> <li>Every call to <code>measure()</code> will result in a callback with either a success or error code.</li> <li>Results of the measurement operation are provided via the <code>onDeviceResult()</code> callback in an <code>OnDeviceResultListener</code> interface (Kotlin or Java). This callback provides two arguments:<ul> <li>A <code>CommandStatus</code> status code (see Kotlin or Java APIs), which will be <code>SUCCESS</code> for a successful operation.</li> <li>A map containing the measurement values as <code>IMeasurementData</code> instances. The keys in this map correspond to the <code>ScanMode</code> enum (see Kotlin or Java APIs) for each measurement value.</li> <li>See Handling Measurement Data for notes on interpreting the measurement data.</li> <li>The supported scan modes for a particular device are provided in the list from <code>getSupportedModes()</code> on the <code>IDeviceCompat</code> instance. Support for a scan mode can also be checked explicitly by calling <code>isModeSupported()</code> on the <code>IDeviceCompat</code> instance. The expected results by device are shown below:</li> </ul> </li> </ul> Device Type M0 M1 M2 Mini \u2610 \u2610 \u2611 Mini 2 \u2610 \u2610 \u2611 Mini 3 \u2610 \u2610 \u2611 Pro \u2610 \u2610 \u2611 Pro 2 \u2610 \u2610 \u2611 QC \u2610 \u2610 \u2611 Spectro 2 (F1.0.0) \u2611 \u2611 \u2610 Spectro 2 (F2.0.0) \u2611 \u2611 \u2611 Spectro L \u2611 \u2611 \u2611 KotlinJava <pre><code>// Device instance\nvar device: IDeviceCompat\n\n// Define callback for measurement\nval measureListener = object : OnDeviceResultListener {\noverride fun onDeviceResult(\nstatus: CommandStatus,\nmeasurements: Map&lt;ScanMode, IMeasurementData&gt;?\n) {\nwhen (status) {\nCommandStatus.SUCCESS -&gt; {\n// Successful operation\n// Handle measurement data here\n// ...        \n}\n\nCommandStatus.ERROR_NOT_READY -&gt; {\n// Did not complete because the device was busy\n// ...          \n}\n\nCommandStatus.ERROR_NOT_SUPPORTED -&gt; {\n// Did not complete because an unsupported scan mode was\n// specified\n// ...          \n}\n\nCommandStatus.ERROR_LOW_POWER -&gt; {\n// Did not complete because the battery level is too low\n// ...\n}\n\nCommandStatus.ERROR_TIMEOUT -&gt; {\n// Timeout when waiting for result\n// ...\n}\n\nCommandStatus.ERROR_AMBIENT_LIGHT -&gt; {\n// Did not complete because of ambient light leakage\n// ...\n}\nelse -&gt; {\n// Did not complete because of other internal error\n// ...          \n}\n}\n}\n}\n\n// Run the measurement\ndevice.measure(measureListener)\n</code></pre> <pre><code>// Device instance\nIDeviceCompat device;\n\n// Define callback for measurement\nOnDeviceResultListener measureListener = (commandStatus, measurements) -&gt; {\nswitch (commandStatus) {\ncase SUCCESS:\n// Successful operation\n// Handle measurement data here\n// ...\nbreak;\ncase ERROR_NOT_READY:\n// Did not complete because the device was busy\n// ...  \nbreak;\ncase ERROR_NOT_SUPPORTED:\n// Did not complete because an unsupported scan mode was\n// specified\n// ... \nbreak;\ncase ERROR_LOW_POWER:\n// Did not complete because the battery level is too low\n// ...\nbreak;\ncase ERROR_TIMEOUT:\n// Timeout when waiting for result\n// ...\nbreak;\ncase ERROR_AMBIENT_LIGHT:\n// Did not complete because of ambient light leakage\n// ...\nbreak;\ndefault:\n// Did not complete because of other internal error\n// ...   \nbreak;\n}\n};\n\n// Run the measurement\ndevice.measure(measureListener);\n</code></pre>"},{"location":"device-operations/#performing-in-field-profiling-calibration-with-reference-tile","title":"Performing in-field profiling / calibration with reference tile","text":"<p>Certain device types support in-field profiling or calibration using a provided reference tile. This process requires first decoding a string from the QR code attached to the reference tile and then directing the user to measure the same tile. Any necessary adjustments/corrections are performed internally by the SDK and/or the Nix device firmware itself.</p> <ul> <li>The in-field calibration procedure may be performed as often or seldom as desired by the user. However, the flag <code>getFieldCalibrationDue()</code> indicates whether or not in-field calibration is recommended for the connected device.<ul> <li>This flag is updated after each regular measurement</li> <li>This flag is determined automatically by both elapsed time and ambient temperature change</li> <li>Calling <code>invalidateFieldCalibration()</code> will force the calibration record to expire on QC and Spectro 2 devices, so that <code>getFieldCalibrationDue()</code> returns <code>true</code></li> </ul> </li> <li>The in-field calibration procedure can exit with status <code>ERROR_SCAN_DELTA</code> if a large difference is detected between the tile reference and measurement. <ul> <li>This status indicates an unexpected tile measurement, possibly due to:<ul> <li>User error (e.g. - a surface other than the reference tile was measured). In this case, the user should repeat the operation</li> <li>The reference tile is damaged</li> <li>The device has drifted too far from factory calibration for the field calibration to be reliable</li> </ul> </li> <li>The failure threshold can vary by device type and can be checked by calling <code>getFieldCalibrationMaxDelta()</code></li> <li>The failure threshold can be overridden by calling <code>setFieldCalibrationMaxDelta()</code> but this is NOT RECOMMENDED</li> </ul> </li> <li>The flag <code>getSupportsFieldCalibration()</code> indicates whether or not a connected device supports this feature. The expected result by device type is shown below: </li> </ul> Device Type Supported Mini \u2610 Mini 2 \u2610 Mini 3 \u2611 Pro \u2610 Pro 2 \u2610 QC \u2611 Spectro 2 \u2611 Spectro L \u2611 <p>The steps to perform in-field profiling include:</p> <ol> <li>Decode the QR code printed on the device reference tile and interpret as a string. Do not parse this data further.</li> <li>Check if the parsed data is valid using <code>isTileStringValid()</code> on the <code>IDeviceCompat</code> instance. If valid, continue to the next step.</li> <li>Instruct the user to place the device on the reference tile.</li> <li>Using the decoded tile string, run the in-field calibration routine by calling <code>runFieldCalibration()</code> on the <code>IDeviceCompat</code> instance and wait for callback (see Kotlin or Java APIs).<ul> <li>This operation is asynchronous and returns immediately. While the operation is in progress, no other commands can be sent to the Nix device (wait for the callback)</li> <li>Every call to <code>runFieldCalibration()</code> will result in a callback with either a success or error code.</li> </ul> </li> </ol> KotlinJava <pre><code>// Device instance\nvar device: IDeviceCompat\n\n// String decoded from the reference tile\nval tileString: String\n\n// Define callback for field calibration\nval calibrateListener = object : OnDeviceResultListener {\noverride fun onDeviceResult(\nstatus: CommandStatus,\nmeasurements: Map&lt;ScanMode, IMeasurementData&gt;?\n) {\nwhen (status) {\nCommandStatus.SUCCESS -&gt; {\n// Successful operation\n// ...        \n}\n\nCommandStatus.ERROR_SCAN_DELTA -&gt; {\n// Operation failed because the measured value of the \n// reference tile is too far from the expected value\n// (high delta E)\n// ...           \n}\n\nCommandStatus.ERROR_NOT_READY -&gt; {\n// Did not complete because the device was busy\n// ...          \n}\n\nCommandStatus.ERROR_NOT_SUPPORTED -&gt; {\n// Did not complete because this device does not support\n// this command\n// ...           \n}\n\nCommandStatus.ERROR_INVALID_ARGUMENT -&gt; {\n// Did not complete because the tileString is invalid\n// ...          \n}\n\nCommandStatus.ERROR_LOW_POWER -&gt; {\n// Did not complete because the battery level is too low\n// ...\n}\n\nCommandStatus.ERROR_TIMEOUT -&gt; {\n// Timeout when waiting for result\n// ...\n}\n\nCommandStatus.ERROR_AMBIENT_LIGHT -&gt; {\n// Did not complete because of ambient light leakage\n// ...\n}\nelse -&gt; {\n// Did not complete because of other internal error\n// ...          \n}\n}\n}\n}\n\n// Run field calibration scan\ndevice.runFieldCalibration(calibrateListener, tileString)\n</code></pre> <pre><code>// Device instance\nIDeviceCompat device;\n\n// String decoded from the reference tile\nString tileString;\n\n// Define callback for field calibration\nOnDeviceResultListener calibrateListener = (commandStatus, measurements) -&gt; {\nswitch (commandStatus) {\ncase SUCCESS:\n// Successful operation\n// ...\nbreak;\ncase ERROR_SCAN_DELTA:\n// Operation failed because the measured value of the reference\n// tile is too far from the expected value (high delta E)\n// ...   \nbreak;\ncase ERROR_NOT_READY:\n// Did not complete because the device was busy\n// ...  \nbreak;\ncase ERROR_NOT_SUPPORTED:\n// Did not complete because this device does not support this\n// command\n// ...\nbreak;\ncase ERROR_INVALID_ARGUMENT:\n// Did not complete because the tileString is invalid\n// ...\nbreak;\ncase ERROR_LOW_POWER:\n// Did not complete because the battery level is too low\n// ...\nbreak;\ncase ERROR_TIMEOUT:\n// Timeout when waiting for result\n// ...\nbreak;\ncase ERROR_AMBIENT_LIGHT:\n// Did not complete because of ambient light leakage\n// ...\nbreak;\ndefault:\n// Did not complete because of other internal error\n// ...   \nbreak;\n}\n};\n\n// Run field calibration scan\ndevice.runFieldCalibration(calibrateListener, tileString);\n</code></pre>"},{"location":"device-operations/#other-device-options","title":"Other device options","text":"<p>Some Nix devices support certain <code>boolean</code> options. These options are set to be enabled by default (if supported) and do not usually need to be changed. Current state and device support can be checked at runtime on the <code>IDeviceCompat</code> instance:</p> <ul> <li>Applying temperature compensation<ul> <li>Current state: <code>getTemperatureCompensationEnabled()</code></li> <li>Is supported?: <code>getSupportsTemperatureCompensation()</code></li> </ul> </li> <li>Applying in-field calibration<ul> <li>Current state: <code>getFieldCalibrationEnabled()</code></li> <li>Is supported?: <code>getSupportsFieldCalibration()</code></li> </ul> </li> <li>Using on-device haptic feedback<ul> <li>Current state: <code>getHapticFeedbackEnabled()</code></li> <li>Is supported?: <code>getSupportsHapticFeedback()</code></li> </ul> </li> <li>Using on-device RGB feedback<ul> <li>Current state: <code>getRgbFeedbackEnabled()</code></li> <li>Is supported?: <code>getSupportsRgbFeedback()</code></li> </ul> </li> </ul> <p>A summary of device support is shown below, but can be checked at runtime.</p> Device type Temp comp. Field cal. Haptic RGB Mini \u2610 \u2610 \u2610 \u2610 Mini 2 \u2611 \u2610 \u2610 \u2610 Mini 3 \u2611 \u2611 \u2610 \u2611 Pro \u2610 \u2610 \u2610 \u2610 Pro 2 \u2611 \u2610 \u2610 \u2610 QC \u2611 \u2611 \u2610 \u2610 Spectro 2 \u2611 \u2611 \u2611 \u2611 Spectro L \u2611 \u2611 \u2611 \u2611 <p>Changing any of these options may require communication with the device itself and is an asynchronous operation, with the status of the operation provided via a <code>onDeviceResult()</code> callback in the specified <code>OnDeviceResultListener</code> interface.</p> <ul> <li>To enable or bypass temperature compensation, use <code>setTemperatureCompensationEnabled()</code></li> <li>To enable or bypass applying in-field calibration, use <code>setFieldCalibrationEnabled()</code> </li> <li>To enable or disable haptic feedback, use <code>setHapticFeedbackEnabled()</code></li> <li>To enable or disable RGB feedback, use <code>setRgbFeedbackEnabled()</code></li> </ul>"},{"location":"device-operations/#other-device-properties","title":"Other device properties","text":"<p>The <code>IDeviceCompat</code> interface defines other properties that can be read once the device has connected and reached an idle state. These include, but are not limited to:</p> <ul> <li><code>getExtPowerState()</code>: status of external power connection / charging</li> <li><code>getBatteryLevel()</code>: current battery level, <code>null</code> otherwise</li> <li><code>getFirmwareVersion()</code>: device firmware revision</li> <li><code>getHardwareVersion()</code>: device hardware revision</li> <li><code>getSoftwareVersion()</code>: device software revision</li> <li><code>getSerialNumber()</code>: device serial number</li> <li><code>getNote()</code>: device allocation / production code</li> <li><code>getProvidesSpectral()</code>: indicates whether or not this device provides spectral data</li> <li><code>getProvidesDensity()</code>: indicates whether or not this device provides density data</li> <li><code>getSupportedReferences()</code>: list of supported reference white values provided by the measurement data from this device</li> </ul> <p>Refer to the <code>IDeviceCompat</code> API reference (Kotlin or Java) for full descriptions of the above properties.</p>"},{"location":"device-operations/#next-steps","title":"Next steps","text":"<ul> <li>Handling Measurement Data</li> </ul>"},{"location":"discovering-connecting/","title":"Discovering and Connecting to Nix Devices","text":"<p>Regardless of device type, each unique Nix device can be represented by an object that conforms to the <code>IDeviceCompat</code> interface (see Kotlin or Java APIs). To obtain instances of the device object, they need to first be discovered using the <code>DeviceScanner</code> (see Kotlin or Java APIs). They can also be recalled at a later time directly using their <code>id</code> property (for Bluetooth connected devices only).</p>"},{"location":"discovering-connecting/#device-discovery","title":"Device discovery","text":"<p>The <code>DeviceScanner</code> implements the <code>IDeviceScanner</code> interface (see Kotlin or Java APIs) and searches for nearby Nix devices using Bluetooth. The <code>DeviceScanner</code> will also report devices connected via USB. Scanner events are reported via:</p> <ul> <li><code>OnScannerStateChangeListener</code>:<ul> <li>Optional callback interface which reports when the scanner starts and stops searching for devices.</li> <li>API reference: Kotlin or Java.</li> <li>This is set using <code>setOnScannerStateChangeListener()</code>.</li> </ul> </li> <li><code>OnDeviceFoundListener</code>:<ul> <li>Callback interface which is called by the scanner each time that an <code>IDeviceCompat</code> instance has been found.</li> <li>API reference: Kotlin or Java.</li> <li>Note that this will be called both when a new device is found and when the RSSI/signal strength of a previously discovered device has changed. It is possible to use the <code>id</code> parameter as a means to uniquely identify discovered devices.</li> </ul> </li> </ul> <p>To use the <code>DeviceScanner</code>:</p> <ul> <li>Initialize a scanner instance</li> <li>Optionally set a <code>OnScannerStateChangeListener</code>, if it is desired to track when the scanner starts and stops a device search</li> <li>Start the scanner using <code>start()</code> (see Kotlin or Java APIs).<ul> <li>By default, the scanner will search for a period <code>DEFAULT_GENERAL_SCAN_PERIOD_MS</code>, but this interval can be overridden by providing an argument for <code>scanPeriodMs</code>.</li> </ul> </li> <li>Observe discovered devices via the <code>onScanResult()</code> in the <code>OnDeviceFoundListener</code> interface. At this stage, it is valid to check a limited number of parameters on the device object:<ul> <li><code>getId()</code>: Device identifier string (see Kotlin or Java APIs).</li> <li><code>getRssi()</code>: Device signal strength (-127 to 0). Will be 0 for USB connected devices (see Kotlin or Java APIs).</li> <li><code>getInterfaceType()</code>: Indicates whether the device was found via Bluetooth or USB connection (see Kotlin or Java APIs).</li> <li><code>getType()</code>: Indicates the specific device type (see Kotlin or Java APIs).</li> <li><code>getName()</code>: Full name of the device (e.g. 'Nix Spectro 2', see Kotlin or Java APIs).</li> </ul> </li> <li>The device search will run for the specified duration, after which <code>onScannerStopped()</code> is called. The device search can also be manually stopped using <code>stop()</code>.</li> </ul> KotlinJava <pre><code>// Define the OnScannerStateChangeListener\nval scannerStateListener = object : OnScannerStateChangeListener {\noverride fun onScannerStarted(sender: IDeviceScanner) {\n// Scanner has started ...\n}\n\noverride fun onScannerStopped(sender: IDeviceScanner) {\n// Scanner has stopped ...\n}\n}\n\n// Define the OnDeviceFoundListener\nval deviceFoundListener = object : OnDeviceFoundListener {\noverride fun onScanResult(sender: IDeviceScanner, device: IDeviceCompat) {\n// Nearby device found\n// Handle discovery here ...\n\n// Valid to query some parameters now:\nLog.d(TAG, String.format(\n\"Found %s (%s) at RSSI %d\", device.id, device.name, device.rssi)\n)\n}\n}\n\n// Application context, in a Fragment use getContext()\nval context: Context = applicationContext\n\n// Initialize the scanner\nval scanner = DeviceScanner(context)\nscanner.setOnScannerStateChangeListener(scannerStateListener)\n\n// Start the scanner\nscanner.start(listener = deviceFoundListener)\n</code></pre> <pre><code>// Define the OnScannerStateChangeListener\nIDeviceScanner.OnScannerStateChangeListener stateChangeListener = new IDeviceScanner.OnScannerStateChangeListener() {\n@Override\npublic void onScannerStarted(@NonNull IDeviceScanner sender) {\n// Scanner has started\n// ...\n}\n\n@Override\npublic void onScannerStopped(@NonNull IDeviceScanner sender) {\n// Scanner has stopped\n// ...\n}\n};\n\n// Define the OnDeviceFoundListener\nIDeviceScanner.OnDeviceFoundListener deviceFoundListener = new IDeviceScanner.OnDeviceFoundListener() {\n@Override\npublic void onScanResult(\n@NonNull IDeviceScanner sender,\n@NonNull IDeviceCompat device\n) {\n// Nearby device found\n// Handle discovery here ...\n\n// Valid to query some parameters now:\nLog.d(TAG, String.format(\n\"Found %s (%s) with RSSI %d\", device.getId(), device.getName(), device.getRssi()));\n}\n};\n\n// Application context, in a Fragment use getContext()\nContext context = getApplicationContext();\n\n// Initialize the scanner\nIDeviceScanner scanner = new DeviceScanner(context);\nscanner.setOnScannerStateChangeListener(scannerStateListener);    // Start the scanner\nscanner.start(\ndeviceFoundListener, IDeviceScanner.DEFAULT_GENERAL_SCAN_PERIOD_MS);\n</code></pre>"},{"location":"discovering-connecting/#recalling-a-known-nix-device","title":"Recalling a known Nix device","text":"<p>For Bluetooth connected devices only, it is possible to construct an <code>IDeviceCompat</code> instance directly if the hardware address and device type is known. The constructor takes the hardware address and device names as arguments.</p> <ul> <li>The device address must match the original value queried from <code>getId()</code>. Note that this corresponds to the hardware address of the advertising Bluetooth device</li> <li>The device name must match the original value queried from <code>getName()</code>. Note that this corresponds to the device name as advertised on Bluetooth. If the <code>DeviceType</code> enum is known, this also corresponds to <code>getFullName()</code> (see Kotlin or Java APIs for <code>DeviceType</code>).</li> </ul> KotlinJava <pre><code>// Application context, in a Fragment use getContext()\nval context: Context = applicationContext\n\n// Hardware address of known device\nval exampleAddress: String = \"00:AA:11:BB:22:CC\"\n\n// Name of known device / type (must match advertised name)\nval exampleName: String = \"Nix Spectro 2\"\n\n// Create IDeviceCompat instance\nval recalledDevice: IDeviceCompat = DeviceCompat(\ncontext = context,\naddress = exampleAddress,\nname = exampleName\n)\n</code></pre> <pre><code>// Application context, in a Fragment use getContext()\nContext context = getApplicationContext();\n\n// Hardware address of known device\nString exampleAddress = \"00:AA:11:BB:22:CC\";\n\n// Name of known device / type (must match advertised name)\nString exampleName = \"Nix Spectro 2\";\n\n// Create IDeviceCompat instance\nIDeviceCompat recalledDevice = new DeviceCompat(\ncontext, exampleAddress, exampleName, Integer.MIN_VALUE);\n</code></pre>"},{"location":"discovering-connecting/#opening-a-connection","title":"Opening a connection","text":"<p>Once an <code>IDeviceCompat</code> instance has been obtained, a connection can be opened by calling <code>connect()</code> (see Kotlin or Java APIs). Connection state changes are provided via an <code>OnDeviceStateChangeListener</code> interface. The connection can be cancelled or closed normally by later calling <code>disconnect()</code>.</p> <p>The steps necessary for connecting include:</p> <ol> <li>Implement the <code>OnDeviceStateChangeListener</code> interface in your class</li> <li>Stop the <code>DeviceScanner</code> before opening a connection, if still running.<ul> <li>It is safe to call <code>stop()</code> on the <code>DeviceScanner</code> at any time, even if already stopped.</li> </ul> </li> <li>Start the connection process by calling <code>connect()</code>.<ul> <li>The connection process is asynchronous and <code>connect()</code> will return immediately. If a connection activity indicator is shown, it can be shown immediately before calling this method.</li> <li>A call to <code>connect()</code> will always result in either the <code>onConnected()</code> or <code>onDisconnected()</code> callback being triggered.</li> <li>Device operations are not possible until the <code>onConnected()</code> callback is received (successful connection)</li> <li>If the connection process fails, the <code>onDisconnected()</code> callback will be invoked with an appropriate status code indicating the cause of the error.</li> <li><code>onDisconnected()</code> will also be called later whenever the device is disconnected. This can occur normally (i.e. - if the host application calls <code>disconnect()</code> on the <code>IDeviceCompat</code> instance), or abnormally (i.e. - if the connection is dropped due to an error or low Bluetooth signal strength).</li> <li>The supplied library binaries are linked to a specific allocation of Nix devices and will not operate with devices from another allocation. At connection time, the SDK will verify an allocation code stored on the Nix device. If this check does not pass, the SDK will contact a Nix authentication server to check if that device serial number is authorized. If the device cannot be authenticated (i.e. \u2013 an unknown allocation code was found and an internet connection is unavailable), the device will be disconnected with the status <code>ERROR_UNAUTHORIZED</code>. The internet connection is required only once every 30 days \u2013 once authorized, this status is saved, and connections can be made offline for this time period.</li> </ul> </li> <li>When the user has finished using the device, the connection can be closed by calling <code>disconnect()</code>.</li> </ol> KotlinJava <pre><code>// Define the OnDeviceStateChangeListener\nval deviceStateListener = object : OnDeviceStateChangeListener {\noverride fun onConnected(\nsender: IDeviceCompat\n) {\n// Device has connected successfully\n// Device properties can now be queried\n// Device commands/operations can now run\n// ...\n}\n\noverride fun onDisconnected(\nsender: IDeviceCompat,\nstatus: DeviceStatus\n) {\n// Handle status codes here, if desired in your application\n// At minimum, should check for ERROR_UNAUTHORIZED status\nwhen (status) {\n// Device not authorized for this SDK build\nDeviceStatus.ERROR_UNAUTHORIZED -&gt; {\n// ...\n}\n\n// Normal disconnect, triggered by device.disconnect()\nDeviceStatus.SUCCESS -&gt; {\n// ...\n}\n\n// Nix device dropped the connection\nDeviceStatus.ERROR_DROPPED_CONNECTION -&gt; {\n// ...\n}\n\n// Connection to Nix device timed out\nDeviceStatus.ERROR_TIMEOUT -&gt; { // ...\n}\n\n// Other internal errors\nDeviceStatus.ERROR_MAX_ATTEMPTS,\nDeviceStatus.ERROR_UNSUPPORTED_DEVICE,\nDeviceStatus.ERROR_INTERNAL -&gt; { // ...\n}\n}\n}\n\noverride fun onBatteryStateChanged(\nsender: IDeviceCompat,\nnewState: Int\n) {\nsuper.onBatteryStateChanged(sender, newState)\n// Battery level has updated\n// ...\n}\n\noverride fun onExtPowerStateChanged(\nsender: IDeviceCompat,\nnewState: Boolean\n) {\nsuper.onExtPowerStateChanged(sender, newState)\n// External power has been connected or disconnected\n// ...\n}        }\n\n// Device instance that has already been found by the DeviceScanner\nvar device: IDeviceCompat\n\n// Initiate the connection\ndevice.connect(deviceStateListener)\n</code></pre> <pre><code>// Define the OnDeviceStateChangeListener\nIDeviceCompat.OnDeviceStateChangeListener deviceStateListener = new IDeviceCompat.OnDeviceStateChangeListener() {\n@Override\npublic void onConnected(@NonNull IDeviceCompat sender) {\n// Device has connected successfully\n// Device properties can now be queried\n// Device commands/operations can now run\n// ...\n}\n\n@Override\npublic void onDisconnected(\n@NonNull IDeviceCompat sender, @NonNull DeviceStatus status) {\n// Handle status codes here, if desired in your application\n// At minimum, should check for ERROR_UNAUTHORIZED status\nswitch (status) {\ncase ERROR_UNAUTHORIZED:\n// Device not authorized for this SDK build\n// ...\nbreak;\ncase SUCCESS:\n// Normal disconnect, triggered by device.disconnect()\n//...\nbreak;\ncase ERROR_DROPPED_CONNECTION:\n// Nix device dropped the connection\n// ...\nbreak;\ncase ERROR_TIMEOUT:\n// Connection to Nix device timed out\n// ...\nbreak;\ncase ERROR_MAX_ATTEMPTS:\ncase ERROR_UNSUPPORTED_DEVICE:\ncase ERROR_INTERNAL:\n// Other internal errors\n// ...\nbreak;\n}\n}\n\n@Override\npublic void onBatteryStateChanged(\n@NonNull IDeviceCompat sender, int newState\n) {\n// Battery level has updated\n// ...\n}\n\n@Override\npublic void onExtPowerStateChanged(\n@NonNull IDeviceCompat sender, boolean newState\n) {\n// External power has been connected or disconnected\n// ...\n}\n};\n\n// Device instance that has already been found by the DeviceScanner\nIDeviceCompat device;\n\n// Initiate the connection\ndevice.connect(deviceStateListener);\n</code></pre>"},{"location":"discovering-connecting/#next-steps","title":"Next steps","text":"<ul> <li>Device Operations </li> </ul>"},{"location":"example-apps/","title":"Example Application","text":""},{"location":"example-apps/#android-application-written-in-kotlin","title":"Android application written in Kotlin","text":"<p>An example app and its complete source code are provided with the <code>NixUniversalSDK</code> download. To review the example, use Android Studio to open the <code>example-android</code> folder.</p> <p>The example app demonstrates:</p> <ul> <li>Device discovery on Bluetooth and USB interfaces</li> <li>Opening and closing a connection to a device</li> <li>Displaying additional device info (serial number, battery level, etc.)</li> <li>Toggling device options (haptic feedback, RGB feedback, etc.)</li> <li>Taking measurements</li> <li>Obtaining colorimetry and spectral data from measurements</li> <li>Performing in-field calibration on the provided reference tile</li> <li>Displaying additional measurement information (temperature, scan settings, etc.)</li> </ul> <p> </p> Demo app screenshot"},{"location":"example-apps/#next-steps","title":"Next steps","text":"<ul> <li>Get additional support</li> </ul>"},{"location":"handling-measurements/","title":"Handling Measurement Data","text":"<p>Measurements from Nix devices are provided as objects conforming to the <code>IMeasurementData</code> interface. These contain all data and metadata to completely describe the measurement. Color, spectral, and density data are obtained from the <code>IMeasurementData</code> instance as <code>IColorData</code>, <code>ISpectralData</code>, and <code>IDensityData</code> respectively. The differences between these object types are listed below.</p>"},{"location":"handling-measurements/#imeasurementdata","title":"IMeasurementData","text":"<ul> <li>Corresponds to a single measurement in a single <code>ScanMode</code> from a Nix device</li> <li>Provides color data as <code>IColorData</code><ul> <li>To get color data, call <code>toColorData()</code></li> <li>All devices provide data for D50/2\u00b0 reference white</li> <li>Some devices provide additional color data for other reference white values</li> <li>To check if available, call <code>providesColor()</code></li> </ul> </li> <li>May provide spectral data as <code>ISpectralData</code>, depending on the device type<ul> <li>To check if available, use <code>getProvidesSpectral()</code> </li> <li>To get spectral data, use <code>getSpectralData()</code> </li> </ul> </li> <li>May provide density data as <code>IDensityData</code>, depending on the device type<ul> <li>To check if available, use <code>getProvidesDensity()</code> </li> <li>To get density data, use <code>toDensityData()</code> </li> </ul> </li> <li>The measurement data contains all data and metadata to completely describe the measurement<ul> <li>For maximum fidelity and ease of use when saving data, save the string data from <code>getRaw()</code>.</li> <li>The raw string value can be used to reconstruct measurement data using <code>fromRaw()</code>.</li> </ul> </li> <li>Refer to the <code>IMeasurementData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#supported-icolordata-output-based-on-device-type","title":"Supported <code>IColorData</code> output based on device type","text":"Reference Mini Mini 2 Mini 3 Pro Pro 2 QC Spectro 2 Spectro L A/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 A/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 C/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 C/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D50/2\u00b0 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 \u2611 D50/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D55/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D55/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D65/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D65/10\u00b0 \u2610 \u2611 \u2611 \u2610 \u2611 \u2611 \u2611 \u2611 D75/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 D75/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F2/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F2/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F7/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F7/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F11/2\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611 F11/10\u00b0 \u2610 \u2610 \u2611 \u2610 \u2610 \u2610 \u2611 \u2611"},{"location":"handling-measurements/#supported-ispectraldata-and-idensitydata-output-based-on-device-type","title":"Supported <code>ISpectralData</code> and <code>IDensityData</code> output based on device type","text":"Device Type Supports spectral output Supports density output Mini \u2610 \u2610 Mini 2 \u2610 \u2610 Mini 3 \u2610 \u2610 Pro \u2610 \u2610 Pro 2 \u2610 \u2610 QC \u2610 \u2610 Spectro 2 \u2611 \u2611 Spectro L \u2611 \u2611"},{"location":"handling-measurements/#icolordata","title":"IColorData","text":"<ul> <li>Consists of colorimetry data for a single reference white point (e.g. - D50/2\u00b0) and single measurement mode (e.g. - M2)</li> <li>Can be obtained directly from an <code>IMeasurementData</code> object, from or an <code>ISpectralData</code> object</li> <li>Full description of a color consisting of:<ul> <li>Type / color system: <code>getType()</code> as <code>ColorType</code> enum </li> <li>Value: <code>getValue()</code> as double array (3 channels)<ul> <li>Format matches the system defined by <code>getType()</code></li> </ul> </li> <li>Reference white point: <code>getReference()</code> as <code>ReferenceWhite</code> enum</li> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code> enum</li> </ul> </li> <li>Regardless of <code>getType()</code>, the color is always backed internally by a CIEXYZ value</li> <li>Color can be converted between any of the types specified in the <code>ColorType</code> enum by calling <code>convertTo()</code></li> <li>Delta E to another <code>IColorData</code> instance can be evaluated using <code>compareTo()</code>.<ul> <li>Both <code>IColorData</code> objects must share the same reference, otherwise the result with be NaN</li> <li>If the color difference type is not specified, the default is CIE2000. See the <code>ColorDifferenceType</code> enum for other options (Kotlin or Java)</li> </ul> </li> <li>sRGB value can be fetched using <code>getRgbValue()</code></li> <li>Refer to the <code>IColorData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#ispectraldata","title":"ISpectralData","text":"<ul> <li>Consists of spectral data for a single measurement mode</li> <li>Obtained from an <code>IMeasurementData</code> object that supports spectral data</li> <li>Full description of the spectral measurement consisting of:<ul> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code> enum</li> <li>Wavelength values: <code>getLambda()</code> as integer array</li> <li>Spectral values: <code>getValue()</code> as float array</li> </ul> </li> <li>Can be used to obtain density data as <code>IDensityData</code> using <code>toDensityData()</code></li> <li>Can be used to obtain colorimetry data as <code>IColorData</code> object for any reference white using <code>toColorData()</code></li> <li>sRGB value can be fetched for any reference white using <code>toRgbValue()</code></li> <li>Refer to the <code>ISpectralData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#idensitydata","title":"IDensityData","text":"<ul> <li>Consists of density data for a single measurement mode and single 'ISO status' / lookup table</li> <li>Obtained from an <code>IMeasurementData</code> object that supports spectral data, or an <code>ISpectralData</code> object</li> <li>Description of the density values for a specific 'ISO Status' consisting of:<ul> <li>Scan mode: <code>getMode()</code> as <code>ScanMode</code></li> <li>ISO status: <code>getStatus()</code> as <code>DensityStatus</code> enum</li> <li>Density values: <code>getValue()</code> as double array (4 channels)<ul> <li>Index 0: C</li> <li>Index 1: M</li> <li>Index 2: Y</li> <li>Index 3: K</li> </ul> </li> <li>Automatic density index: <code>getAutoIndex()</code> as integer value</li> </ul> </li> <li>Refer to the <code>IDensityData</code> API documentation for full details (Kotlin or Java)</li> </ul>"},{"location":"handling-measurements/#other-utilities","title":"Other utilities","text":"<p>The <code>ColorUtils</code> class provides many helpful functions for manual colour conversions and delta E calculations. Further details are provided in the API reference (Kotlin and Java)</p>"},{"location":"handling-measurements/#next-steps","title":"Next steps","text":"<ul> <li>Review the example app</li> <li>Get additional support</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#version-410","title":"Version 4.1.0","text":"<ul> <li>Added support for Nix Spectro L devices</li> <li>Added <code>IDeviceCompat/fieldCalibrationMaxDelta</code><ul> <li>Allows override of the maximum Delta E threshold used when performing in-field calibration</li> <li>Review the API reference (Kotlin or Java getter and setter) for additional details</li> </ul> </li> <li>Updated field calibration routine for Nix Spectro 2 devices<ul> <li>API calls to <code>IDeviceCompat/runFieldCalibration</code> function are unchanged</li> <li>Additional diagnostics are performed during the white tile scan on Spectro 2 type devices. As a result, the calibration command can now take 5 - 10 seconds to complete</li> <li>The operation can now fail with status <code>CommandStatus/ERROR_SCAN_DELTA</code> if the tile measurement delta exceeds the allowable threshold</li> </ul> </li> <li>Added <code>IDeviceCompat/invalidateFieldCalibration</code> function<ul> <li>This function forces the field calibration record to expire on QC and Spectro 2 type devices. </li> <li>Review the API reference (Kotlin or Java) for additional details</li> </ul> </li> </ul>"},{"location":"release-notes/#version-402","title":"Version 4.0.2","text":"<ul> <li>Added ISO Density calculations and supporting classes<ul> <li>Density data can be obtained from measurements as <code>IDensityData</code></li> <li>The Handling Measurement Data article has been updated to reflect its usage</li> </ul> </li> </ul>"},{"location":"release-notes/#version-400","title":"Version 4.0.0","text":"<ul> <li>Initial release for <code>NixUniversalSDK</code>, replacing the older <code>nixlibrary</code> project</li> </ul>"}]}